import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable
import matplotlib.patches as patches
from typing import Optional, Union
from tqdm import tqdm
import warnings

"""
This file is generated by claude from original matlab "visual.m" 
"""

class HomogenizationVisualizer:
    """
    Visualization tools for homogenized elasticity tensors.
    """
    
    def __init__(self,
                 CH_voigt: Optional[np.ndarray] = None,
                 CH_tensor: Optional[np.ndarray] = None,
                 cell_name="cell"):
        """
        Initialize visualizer with homogenized elasticity tensor.

        Args:
            CH_voigt: 6x6 elasticity tensor in Voigt notation
            CH_tensor: 3x3x3x3 elasticity tensor in full notation
        """
        self.CH_voigt = CH_voigt
        self.CH_tensor = CH_tensor
        self.cell_name = cell_name   #   cell name for plotting
        
        if CH_voigt is not None:
            self._convert_voigt_to_tensor()
        elif CH_tensor is not None:
            self._convert_tensor_to_voigt()
    
    def load_from_files(self, voigt_file: str = None, tensor_file: str = None):
        """
        Load elasticity tensor from saved files.
        
        Args:
            voigt_file: Path to Voigt notation file (.txt)
            tensor_file: Path to tensor file (.npy)
        """
        if voigt_file:
            self.CH_voigt = np.loadtxt(voigt_file)
            self._convert_voigt_to_tensor()
        elif tensor_file:
            self.CH_tensor = np.load(tensor_file)
            self._convert_tensor_to_voigt()
    
    def _convert_voigt_to_tensor(self):
        """Convert Voigt notation to full tensor notation."""
        if self.CH_voigt is None:
            return
        
        self.CH_tensor = np.zeros((3, 3, 3, 3))
        voigt_map = [(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (0, 2)]
        
        for i in range(6):
            for j in range(6):
                a, b = voigt_map[i]
                c, d = voigt_map[j]
                
                self.CH_tensor[a, b, c, d] = self.CH_voigt[i, j]
                if a != b:
                    self.CH_tensor[b, a, c, d] = self.CH_voigt[i, j]
                if c != d:
                    self.CH_tensor[a, b, d, c] = self.CH_voigt[i, j]
                if a != b and c != d:
                    self.CH_tensor[b, a, d, c] = self.CH_voigt[i, j]
    
    def _convert_tensor_to_voigt(self):
        """Convert tensor notation to Voigt notation."""
        if self.CH_tensor is None:
            return
        
        self.CH_voigt = np.zeros((6, 6))
        voigt_map = [(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (0, 2)]
        
        for i in range(6):
            for j in range(6):
                a, b = voigt_map[i]
                c, d = voigt_map[j]
                self.CH_voigt[i, j] = self.CH_tensor[a, b, c, d]

    @staticmethod
    def _transform_tensor(tensor: np.ndarray, rotation_matrix: np.ndarray) -> np.ndarray:
        """
        Transform 4th-order tensor using rotation matrix.
        
        Args:
            tensor: 3x3x3x3 tensor
            rotation_matrix: 3x3 rotation matrix
            
        Returns:
            Transformed tensor
        """
        R = rotation_matrix
        transformed = np.zeros((3, 3, 3, 3))
        
        for i in range(3):
            for j in range(3):
                for k in range(3):
                    for l in range(3):
                        for p in range(3):
                            for q in range(3):
                                for r in range(3):
                                    for s in range(3):
                                        transformed[i, j, k, l] += (R[i, p] * R[j, q] * 
                                                                   R[k, r] * R[l, s] * 
                                                                   tensor[p, q, r, s])
        return transformed
    
    def _get_young_modulus_direction(self, direction: np.ndarray) -> float:
        """
        Calculate Young's modulus in a specific direction.
        
        Args:
            direction: Unit direction vector [3]
            
        Returns:
            Young's modulus in that direction
        """
        # Normalize direction vector
        n = direction / np.linalg.norm(direction)
        
        # Create rotation matrix to align x-axis with direction
        if np.allclose(n, [1, 0, 0]):
            R = np.eye(3)
        elif np.allclose(n, [-1, 0, 0]):
            R = np.array([[-1, 0, 0], [0, 1, 0], [0, 0, -1]])
        else:
            # Use Rodrigues' rotation formula
            v = np.cross([1, 0, 0], n)
            s = np.linalg.norm(v)
            c = np.dot([1, 0, 0], n)
            
            if s != 0:
                vx = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
                R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))
            else:
                R = np.eye(3)
        
        # Transform tensor
        C_rot = self._transform_tensor(self.CH_tensor, R)
        
        # Convert to Voigt and get compliance
        C_voigt_rot = np.zeros((6, 6))
        voigt_map = [(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (0, 2)]
        
        for i in range(6):
            for j in range(6):
                a, b = voigt_map[i]
                c, d = voigt_map[j]
                C_voigt_rot[i, j] = C_rot[a, b, c, d]
        
        # Calculate Young's modulus E1 in the rotated coordinate system
        try:
            S_rot = np.linalg.inv(C_voigt_rot)
            E = 1 / S_rot[0, 0]
            return E
        except np.linalg.LinAlgError:
            return 0.0
    
    def plot_voigt_matrix(self, title: str = "Homogenized Elasticity Tensor", 
                         figsize: tuple = (10, 8), save_path: str = None):
        """
        Plot the Voigt elasticity matrix as a heatmap.
        
        Args:
            title: Plot title
            figsize: Figure size
            save_path: Path to save figure (optional)
        """
        if self.CH_voigt is None:
            raise ValueError("No Voigt tensor available for plotting")
        
        fig, ax = plt.subplots(figsize=figsize)
        
        # Create heatmap
        im = ax.imshow(self.CH_voigt, cmap='viridis', aspect='equal')
        
        # Add colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Elasticity Coefficients (Pa)', rotation=270, labelpad=20)
        
        # Set labels and title
        labels = ['11', '22', '33', '12', '23', '13']
        ax.set_xticks(range(6))
        ax.set_yticks(range(6))
        ax.set_xticklabels(labels)
        ax.set_yticklabels(labels)
        ax.set_xlabel('Column Index')
        ax.set_ylabel('Row Index')
        ax.set_title(title + f' ({self.cell_name})')
        
        # Add text annotations
        for i in range(6):
            for j in range(6):
                 ax.text(j, i, f'{self.CH_voigt[i, j]:.2e}',
                              ha="center", va="center", color="white", fontsize=8)
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        plt.show()
    
    def plot_engineering_constants_comparison(self, reference_E: float = None, 
                                            reference_nu: float = None,
                                            figsize: tuple = (12, 8), 
                                            save_path: str = None):
        """
        Plot engineering constants comparison.
        
        Args:
            reference_E: Reference Young's modulus for comparison
            reference_nu: Reference Poisson's ratio for comparison
            figsize: Figure size
            save_path: Path to save figure
        """
        if self.CH_voigt is None:
            raise ValueError("No tensor available for analysis")
        
        # Calculate compliance matrix and engineering constants
        S = np.linalg.inv(self.CH_voigt)
        
        E1 = 1 / S[0, 0]
        E2 = 1 / S[1, 1]
        E3 = 1 / S[2, 2]
        G12 = 1 / S[3, 3]
        G23 = 1 / S[4, 4]
        G13 = 1 / S[5, 5]
        nu12 = -S[0, 1] * E1
        nu23 = -S[1, 2] * E2
        nu13 = -S[0, 2] * E1
        
        # Create subplots
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=figsize)
        
        # Plot Young's moduli
        E_values = [E1, E2, E3]
        E_labels = ['E₁', 'E₂', 'E₃']
        bars1 = ax1.bar(E_labels, E_values, color=['red', 'green', 'blue'], alpha=0.7)
        if reference_E:
            ax1.axhline(y=reference_E, color='black', linestyle='--', 
                       label=f'Reference E = {reference_E:.2e} Pa')
            ax1.legend()
        ax1.set_ylabel('Young\'s Modulus (Pa)')
        ax1.set_title('Young\'s Moduli')
        ax1.ticklabel_format(style='scientific', axis='y', scilimits=(0,0))
        
        # Add value labels on bars
        for bar, value in zip(bars1, E_values):
            height = bar.get_height()
            ax1.annotate(f'{value:.2e}', xy=(bar.get_x() + bar.get_width()/2, height),
                        xytext=(0, 3), textcoords="offset points", ha='center', va='bottom',
                        fontsize=9, rotation=0)
        
        # Plot shear moduli
        G_values = [G12, G23, G13]
        G_labels = ['G₁₂', 'G₂₃', 'G₁₃']
        bars2 = ax2.bar(G_labels, G_values, color=['orange', 'purple', 'brown'], alpha=0.7)
        ax2.set_ylabel('Shear Modulus (Pa)')
        ax2.set_title('Shear Moduli')
        ax2.ticklabel_format(style='scientific', axis='y', scilimits=(0,0))
        
        for bar, value in zip(bars2, G_values):
            height = bar.get_height()
            ax2.annotate(f'{value:.2e}', xy=(bar.get_x() + bar.get_width()/2, height),
                        xytext=(0, 3), textcoords="offset points", ha='center', va='bottom',
                        fontsize=9, rotation=0)
        
        # Plot Poisson's ratios
        nu_values = [nu12, nu23, nu13]
        nu_labels = ['ν₁₂', 'ν₂₃', 'ν₁₃']
        bars3 = ax3.bar(nu_labels, nu_values, color=['cyan', 'magenta', 'yellow'], alpha=0.7)
        if reference_nu:
            ax3.axhline(y=reference_nu, color='black', linestyle='--', 
                       label=f'Reference ν = {reference_nu:.3f}')
            ax3.legend()
        ax3.set_ylabel('Poisson\'s Ratio')
        ax3.set_title('Poisson\'s Ratios')
        
        for bar, value in zip(bars3, nu_values):
            height = bar.get_height()
            ax3.annotate(f'{value:.3f}', xy=(bar.get_x() + bar.get_width()/2, height),
                        xytext=(0, 3), textcoords="offset points", ha='center', va='bottom',
                        fontsize=9)
        
        # Summary table
        ax4.axis('off')
        table_data = [
            ['Property', 'Value', 'Unit'],
            ['E₁', f'{E1:.3e}', 'Pa'],
            ['E₂', f'{E2:.3e}', 'Pa'], 
            ['E₃', f'{E3:.3e}', 'Pa'],
            ['G₁₂', f'{G12:.3e}', 'Pa'],
            ['G₂₃', f'{G23:.3e}', 'Pa'],
            ['G₁₃', f'{G13:.3e}', 'Pa'],
            ['ν₁₂', f'{nu12:.4f}', '-'],
            ['ν₂₃', f'{nu23:.4f}', '-'],
            ['ν₁₃', f'{nu13:.4f}', '-']
        ]
        
        table = ax4.table(cellText=table_data, cellLoc='center', loc='center',
                         bbox=[0, 0, 1, 1])
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1, 1.5)
        
        # Style header row
        for i in range(3):
            table[(0, i)].set_facecolor('#40466e')
            table[(0, i)].set_text_props(weight='bold', color='white')
        
        plt.suptitle('Engineering Constants Summary' + f' ({self.cell_name})', fontsize=16, fontweight='bold')
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        plt.show()

    def plot_directional_young_modulus_3d(self, resolution: int = 100,
                                         figsize: tuple = (12, 10),
                                         save_path: str = None):
        """
        Create 3D surface plot of directional Young's modulus.
        Similar to MATLAB's visual.m function.

        Args:
            resolution: Angular resolution for the plot
            figsize: Figure size
            save_path: Path to save figure
        """
        if self.CH_tensor is None:
            raise ValueError("No tensor available for directional analysis")

        print("Computing directional Young's modulus (this may take a moment)...")

        # Create angular grid (spherical coordinates)
        azimuth = np.linspace(0, 2*np.pi, resolution)  # azimuthal angle
        elevation = np.linspace(-np.pi/2, np.pi/2, resolution//2)  # polar angle
        AZ, EL = np.meshgrid(azimuth, elevation)

        # Initialize Young's modulus array
        E_values = np.zeros_like(AZ)

        # Calculate Young's modulus for each direction
        total_points = AZ.size
        with tqdm(total=total_points, desc="Computing E(θ,φ)",
                  unit="points", ncols=80, colour='green') as pbar:
            for i in range(AZ.shape[0]):
                for j in range(AZ.shape[1]):
                    # Convert spherical to Cartesian coordinates (unit vector)
                    x = np.cos(EL[i, j]) * np.cos(AZ[i, j])
                    y = np.cos(EL[i, j]) * np.sin(AZ[i, j])
                    z = np.sin(EL[i, j])
                    direction = np.array([x, y, z])
                    E_values[i, j] = self._get_young_modulus_direction(direction)

                    pbar.update(1)

        # Convert to Cartesian coordinates for plotting (scaled by Young's modulus)
        X = E_values * np.cos(EL) * np.cos(AZ)
        Y = E_values * np.cos(EL) * np.sin(AZ)
        Z = E_values * np.sin(EL)

        # Create 3D plot
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection='3d')

        # Create surface plot with color mapping
        ax.plot_surface(X, Y, Z,
                          facecolors=plt.cm.viridis(E_values/E_values.max()),
                          rstride=1, cstride=1,
                          linewidth=0, antialiased=False,
                          shade=True, alpha=0.8)
        
        # Add colorbar
        m = ScalarMappable(cmap='viridis')
        m.set_array(E_values)
        cbar = plt.colorbar(m, ax=ax, shrink=0.5, aspect=5)
        cbar.set_label('Young\'s Modulus (Pa)', rotation=270, labelpad=15)

        # Set labels and title
        ax.set_xlabel('X Direction')
        ax.set_ylabel('Y Direction')
        ax.set_zlabel('Z Direction')
        ax.set_title('Directional Young\'s Modulus\n(Surface radius ∝ Young\'s modulus)' + f' ({self.cell_name})',
                    fontsize=14, pad=20)

        # Set equal aspect ratio
        max_range = np.array([X.max()-X.min(), Y.max()-Y.min(), Z.max()-Z.min()]).max() / 2.0
        mid_x = (X.max()+X.min()) * 0.5
        mid_y = (Y.max()+Y.min()) * 0.5
        mid_z = (Z.max()+Z.min()) * 0.5
        ax.set_xlim(mid_x - max_range, mid_x + max_range)
        ax.set_ylim(mid_y - max_range, mid_y + max_range)
        ax.set_zlim(mid_z - max_range, mid_z + max_range)

        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')

        plt.show()

        # Print statistics
        print(f"\nDirectional Young's Modulus Statistics:")
        print(f"Maximum: {E_values.max():.3e} Pa")
        print(f"Minimum: {E_values.min():.3e} Pa")
        print(f"Average: {E_values.mean():.3e} Pa")
        print(f"Anisotropy ratio (max/min): {E_values.max()/E_values.min():.2f}")
    
    def plot_directional_young_modulus_2d(self, plane: str = 'xy', 
                                         resolution: int = 100, 
                                         figsize: tuple = (10, 8), 
                                         save_path: str = None):
        """
        Create 2D polar plot of directional Young's modulus in a specific plane.
        
        Args:
            plane: Plane to plot ('xy', 'xz', or 'yz')
            resolution: Angular resolution for the plot
            figsize: Figure size
            save_path: Path to save figure
        """
        if self.CH_tensor is None:
            raise ValueError("No tensor available for directional analysis")
        
        # Define angles
        angles = np.linspace(0, 2*np.pi, resolution)
        E_values = np.zeros(resolution)
        
        print(f"Computing directional Young's modulus in {plane.upper()} plane...")
        
        # Calculate Young's modulus for each direction in the specified plane
        for i, angle in enumerate(angles):
            if plane.lower() == 'xy':
                direction = np.array([np.cos(angle), np.sin(angle), 0.0])
            elif plane.lower() == 'xz':
                direction = np.array([np.cos(angle), 0.0, np.sin(angle)])
            elif plane.lower() == 'yz':
                direction = np.array([0.0, np.cos(angle), np.sin(angle)])
            else:
                raise ValueError("Plane must be 'xy', 'xz', or 'yz'")
            
            E_values[i] = self._get_young_modulus_direction(direction)
        
        # Create polar plot
        fig, ax = plt.subplots(figsize=figsize, subplot_kw=dict(projection='polar'))
        
        # Plot the data
        ax.plot(angles, E_values, linewidth=2, color='blue')
        ax.fill(angles, E_values, alpha=0.3, color='lightblue')
        
        # Add grid and labels
        ax.grid(True)
        ax.set_title(f'Directional Young\'s Modulus in {plane.upper()} Plane' + f' ({self.cell_name})',
                    va='bottom', pad=20, fontsize=14)
        
        # Add colorbar for reference
        norm = Normalize(vmin=E_values.min(), vmax=E_values.max())
        sm = ScalarMappable(norm=norm, cmap='viridis')
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax, shrink=0.8, pad=0.1)
        cbar.set_label('Young\'s Modulus (Pa)', rotation=270, labelpad=15)
        
        # Set radial limits
        ax.set_ylim(0, E_values.max() * 1.1)
        
        # Add statistics as text
        stats_text = f'Max: {E_values.max():.2e} Pa\nMin: {E_values.min():.2e} Pa\nRatio: {E_values.max()/E_values.min():.2f}'
        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, 
                bbox=dict(boxstyle='round', facecolor='white', alpha=0.8),
                verticalalignment='top', fontsize=10)
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        plt.show()
        
        return angles, E_values
    
    def plot_anisotropy_analysis(self, figsize: tuple = (15, 5), save_path: str = None):
        """
        Create comprehensive anisotropy analysis plots.
        
        Args:
            figsize: Figure size
            save_path: Path to save figure
        """
        if self.CH_voigt is None:
            raise ValueError("No tensor available for analysis")
        
        fig, axes = plt.subplots(1, 3, figsize=figsize)
        
        # Calculate principal directions and values
        S = np.linalg.inv(self.CH_voigt)
        
        # Extract main diagonal compliance values
        S11, S22, S33 = S[0,0], S[1,1], S[2,2]
        E1, E2, E3 = 1/S11, 1/S22, 1/S33
        
        # 1. Young's modulus comparison
        directions = ['E₁', 'E₂', 'E₃']
        E_values = [E1, E2, E3]
        colors = ['red', 'green', 'blue']
        
        bars = axes[0].bar(directions, E_values, color=colors, alpha=0.7)
        axes[0].set_ylabel('Young\'s Modulus (Pa)')
        axes[0].set_title('Principal Young\'s Moduli')
        axes[0].ticklabel_format(style='scientific', axis='y', scilimits=(0,0))
        
        for bar, value in zip(bars, E_values):
            height = bar.get_height()
            axes[0].annotate(f'{value:.2e}', 
                           xy=(bar.get_x() + bar.get_width()/2, height),
                           xytext=(0, 3), textcoords="offset points", 
                           ha='center', va='bottom', fontsize=9)
        
        # 2. Anisotropy ratios
        ratios = [
            E1/E2 if E2 > 0 else 0,
            E2/E3 if E3 > 0 else 0,
            E1/E3 if E3 > 0 else 0
        ]
        ratio_labels = ['E₁/E₂', 'E₂/E₃', 'E₁/E₃']
        
        bars2 = axes[1].bar(ratio_labels, ratios, color=['orange', 'purple', 'brown'], alpha=0.7)
        axes[1].set_ylabel('Anisotropy Ratio')
        axes[1].set_title('Young\'s Modulus Anisotropy Ratios')
        axes[1].axhline(y=1.0, color='black', linestyle='--', alpha=0.5, 
                       label='Isotropic (ratio = 1)')
        axes[1].legend()
        
        for bar, value in zip(bars2, ratios):
            height = bar.get_height()
            axes[1].annotate(f'{value:.2f}', 
                           xy=(bar.get_x() + bar.get_width()/2, height),
                           xytext=(0, 3), textcoords="offset points", 
                           ha='center', va='bottom', fontsize=9)
        
        # 3. Material symmetry analysis
        # Check for various symmetries by comparing tensor components
        symmetries = self._analyze_material_symmetry()
        
        axes[2].axis('off')
        symmetry_text = "Material Symmetry Analysis:\n" + "="*30 + "\n"
        for key, value in symmetries.items():
            status = "✓" if value else "✗"
            symmetry_text += f"{status} {key}\n"
        
        axes[2].text(0.1, 0.9, symmetry_text, transform=axes[2].transAxes,
                    fontsize=12, verticalalignment='top', fontfamily='monospace',
                    bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.8))
        plt.title('Anisotropy Analysis' + f' ({self.cell_name})', fontsize=16, fontweight='bold')
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        plt.show()
    
    def _analyze_material_symmetry(self, tolerance: float = 1e-6) -> dict:
        """
        Analyze material symmetry based on elasticity tensor.
        
        Args:
            tolerance: Numerical tolerance for symmetry detection
            
        Returns:
            Dictionary with symmetry analysis results
        """
        C = self.CH_voigt
        
        # Check for various material symmetries
        symmetries = {}
        
        # Isotropic: Only C11, C12, C44 are independent
        # C11 = C22 = C33, C12 = C13 = C23, C44 = C55 = C66
        isotropic = (abs(C[0,0] - C[1,1]) < tolerance * C[0,0] and 
                    abs(C[1,1] - C[2,2]) < tolerance * C[0,0] and
                    abs(C[0,1] - C[0,2]) < tolerance * abs(C[0,1]) and
                    abs(C[0,1] - C[1,2]) < tolerance * abs(C[0,1]) and
                    abs(C[3,3] - C[4,4]) < tolerance * C[3,3] and
                    abs(C[4,4] - C[5,5]) < tolerance * C[3,3])
        
        # Transverse isotropy (one axis of symmetry)
        # Assume symmetry about z-axis: C11 = C22, C13 = C23, C44 = C55
        transverse_iso = (abs(C[0,0] - C[1,1]) < tolerance * C[0,0] and
                         abs(C[0,2] - C[1,2]) < tolerance * abs(C[0,2]) and
                         abs(C[3,3] - C[4,4]) < tolerance * C[3,3])
        
        # Orthotropic: 9 independent constants
        # Check if off-diagonal shear terms are zero
        orthotropic = (abs(C[0,3]) < tolerance * C[0,0] and
                      abs(C[0,4]) < tolerance * C[0,0] and
                      abs(C[0,5]) < tolerance * C[0,0] and
                      abs(C[1,3]) < tolerance * C[0,0] and
                      abs(C[1,4]) < tolerance * C[0,0] and
                      abs(C[1,5]) < tolerance * C[0,0] and
                      abs(C[2,3]) < tolerance * C[0,0] and
                      abs(C[2,4]) < tolerance * C[0,0] and
                      abs(C[2,5]) < tolerance * C[0,0])
        
        symmetries['Isotropic'] = isotropic
        symmetries['Transverse Isotropic'] = transverse_iso and not isotropic
        symmetries['Orthotropic'] = orthotropic and not transverse_iso
        symmetries['Anisotropic'] = not (isotropic or transverse_iso or orthotropic)
        
        return symmetries

if __name__ == '__main__':
    CH = np.array([
        [15.5351, 1.3104, 1.3104, 0.0, 0.0, 0.0],
        [1.3104, 15.5351, 1.3104, 0.0, 0.0, 0.0],
        [1.3104, 1.3104, 15.5351, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.7504, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0, 0.7504, 0.0],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.7504],
    ])
    visualizer = HomogenizationVisualizer(CH_voigt=CH, cell_name="test cell")
    visualizer.plot_directional_young_modulus_2d(plane='xy')
    visualizer.plot_directional_young_modulus_3d()
    visualizer.plot_anisotropy_analysis()
    visualizer.plot_voigt_matrix()

